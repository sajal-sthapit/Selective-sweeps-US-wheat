---
title: "Calculations of Fst, Rsb and xpEHH"
author: "Sajal Sthapit"
date: "6/21/2022"
output: html_document
---

```{r message=FALSE, warning=FALSE}
rm(list = ls())
source("functions/functions_for_selection_sweep_analysis.R") # load custom functions for the analysis
library(tidyverse)
library(rehh)
geno <- list(nuc = read_tsv("data/genotype_nucleotide_format_10391_loci_imputed.txt"),
             ab  = read_tsv("data/genotype_AB_format_10391_loci_imputed.txt"))
res <- readRDS("output/allele_freq_Fst_Rsb_xpEHH.Rds")
```

# Calculate and save candidate regions
On 10/21/20, I checked the RSB candidate regions and compared with the input for calc_candidate_regions and found that only positive RSB values were selected for candidate regions.
My previous output only selected for positive threshold values for candidate regions (ignore_sign = TRUE, default is FALSE, even though the the help says otherwise.) For iHS, I need to ignore sign, but doing that increases candidate regions to 2004 from 661. That means, for iHS I may need to use higher thresholds.
The outputs saved on 10/21/20 include negative IHS candidate regions as well. For RSB and XPEHH, we stuck with positive only as we are only interested in loci selected in the target population and not the reference population. The only change from last version is more candidate regions reported in iHS, which is already higher than Rsb and xpehh. It will also not change the manhattan plots, as I use the raw data for that. But the selection map will need to be updated.
# 02/11/21: The global parameters led to too few candidate regions in some states. To be useful for breeding programs, it would make sense to have a minimum number of candidate regions to explore. Hence, for the state population, we also searched for candidate regions by lowering the threshold in order to select the top 10 candidate regions for each statistic.
# To run this chunk, need to have g.pos and conv_names_to_labels() pre-loaded
# 3/29/21: When I specify maxgap, I lose too many candidate regions. A compromise would be to keep unlimited max gap, but increase window size to 95 percentile of gapsize.

```{r set parameters}
# Set parameters ----
res$scan_hh.parameters %>% as.character()
res$snp.gap.percentile
res$snp.gap.quantile
param <- list(thres = 2, min.mrk = 6, min.perc = 80, ws = 2.5e6, ovr = 0.2)
```
The rehh::calc_candidate_regions() outputs a data frame with candidate regions for each population. Then chunk below combines the different population-specific data frames into one dataframe.

```{r scan for candidate regions with defined parameters}
# select scan_hh results only ----
names(res)
# clean the output by removing populations I do not need ----
# Since I was constantly filtering out populations I do not want to plot in Excel, I decided to filter them here. If you do not want to exclude any populations, ignore the following 2 lines and activate the next 2 lines.
rsb <- res$rsb
(pop.rsbxpe <- names(rsb))

# Identify candidate regions for Rsb ----
cr.rsb <- map(.x = rsb[pop.rsbxpe], # if you want to scan all pops, use rsb
              .f = ~ calc_candidate_regions(scan = .x, threshold = param$thres,
                                              ignore_sign = FALSE, # for RSB we only want +ve
                                            window_size = param$ws, overlap = param$ws*param$ovr,
                                            min_n_mrk = param$min.mrk,
                                            min_perc_extr_mrk = param$min.perc))
rsb$both.all2 %>% nrow()
map_dbl(.x = cr.rsb, .f = ~ nrow(.x)) %>% sum(.) # gross number of Rsb candidate regions
cr.rsb.df <- conv_names_to_labels(inp = cr.rsb, sep = "\\.") # this throws up a warning even though xpe does not
table(cr.rsb.df$Category)

# Identify candidate regions for xpEHH ----
xpe <- res$xpe
cr.xpe <- map(.x = xpe[pop.rsbxpe], # if you want to scan all pops, use xpe
              .f = ~ calc_candidate_regions(scan = .x, threshold = param$thres,
                                            ignore_sign = FALSE, # FALSE if you only want +ve
                                            window_size = param$ws, overlap = param$ws*param$ovr,
                                            min_n_mrk = param$min.mrk,
                                            min_perc_extr_mrk = param$min.perc))
map_dbl(.x = cr.xpe, .f = ~ nrow(.x)) %>% sum(.) # = gross number of xpEHH candidate regions
cr.xpe.df <- conv_names_to_labels(inp = cr.xpe, sep = "\\.")
table(cr.xpe.df$Category)

# Identify candidate regions for Fst ----
# Fst filtered for the 5% outliers for each pair wise comparison
fst <- res$fst
quantile.threshold.95 <- map_dbl(.x = names(fst), .f = ~ quantile(fst[[.x]][["FST"]], 0.95, na.rm = TRUE))
quantile.threshold.99 <- map_dbl(.x = names(fst), .f = ~ quantile(fst[[.x]][["FST"]], 0.99, na.rm = TRUE))
quantile.threshold.997 <- map_dbl(.x = names(fst), .f = ~ quantile(fst[[.x]][["FST"]], 0.997, na.rm = TRUE))
names(quantile.threshold.95) <- names(fst)
names(quantile.threshold.99) <- names(fst)
names(quantile.threshold.997) <- names(fst)
quantile.threshold.95
quantile.threshold.99
quantile.threshold.997
par(mfrow = c(1, 3))
hist(quantile.threshold.95, main = "Quantile threshold of ~2 SD")
hist(quantile.threshold.99, main = "Quantile threshold of ~2.5 SD")
hist(quantile.threshold.997, main = "Quantile threshold of ~3 SD")
# use PIC value to determine what direction the selection is happening in Fst.
allele.freq <- map(.x = res$allele.freq, .f = ~ mutate(.x, pic = 1 - (frq.A^2 + frq.C^2 + frq.G^2 + frq.T^2) ))
pop.pairs <- res$pop.pairs
# delta.pic <- map2(.x = pop.pairs$pop1, .y = pop.pairs$pop2, .f = ~ allele.freq[[.x]][["pic"]] - allele.freq[[.y]][["pic"]] )
# names(delta.pic) <- pop.pairs$pop1
# detla.pic will not work when frequency of A/C goes from 0.99/0.01 to 0.01/0.99 because the PIC will remain same.
# Fst value is a measure of differentiation, which can be great when frequency of A/C goes from 0.7/0.3 to 0.3/0.7. This would mean the PIC will remain the same.
# For selection in our context, we want high Fst value combined with low diversity in target population. Since Rsb and xpEHH are effective at 0.7-0.9 allele frequency, for Fst, we will require allele frequency to be 0.9:0.1, which is less or equal to a PIC of 0.18
fst.mod <- map2(.x = fst, .y = names(fst), 
                .f = ~ cbind(.x, allele.freq[[.y]]["pic"]) %>% 
                  mutate(., FST.MOD = ifelse(pic < 0.18, FST, NA)))
# modifies the fst so that we only consider selection in the target population
cr.fst <- map(.x = names(fst.mod), # if you want to scan all pops, use rsb
              .f = ~ calc_candidate_regions(scan = data.frame(CHR = fst.mod[[.x]][["CHR"]],
                                                              POSITION = fst.mod[[.x]][["POSITION"]],
                                                              RSB = fst.mod[[.x]][["FST.MOD"]]), 
                                            # the input for calc_candidate_regions needs to be a data.frame and needs to have a column named IHS, RSB, or XPEHH. If such a column is not found, it uses the third column, but generates warning messages in the console. Hence, I just renamed the column to RSB within this map function to avoid the warning messages.
                                            threshold = quantile.threshold.95[[.x]],
                                            ignore_sign = FALSE, 
                                            window_size = param$ws, overlap = param$ws*param$ovr,
                                            min_n_mrk = param$min.mrk,
                                            min_perc_extr_mrk = param$min.perc))
names(cr.fst) <- names(fst.mod)
rm(fst.mod)
map_dbl(.x = cr.fst, .f = ~nrow(.x)) %>% sum(.)
(num.cr <- map_dbl(.x = cr.fst, .f = ~nrow(.x)))
cr.fst.df <- conv_names_to_labels(inp = cr.fst[num.cr > 0], sep = "\\.") # added this modifier as some populations did not have any candidate regions.
```

# Add SNPid, cM, other info, allele frequencies, PIC, to Rsb, xpEHH, Fst outputs
The Rsb, and xpEHH outputs include CHR and POSITION but no marker names. By adding marker names directly to these results, it will be easier to identify SNP with highest values in a candidate region to then look for patterns across population to write the discussion.
```{r}
g.pos <- mutate(geno$ab[1:6], chr.pos = str_c(Chrom, "_", pos)) %>% select(., SNPid, cM, chr.pos)

# update Rsb with chr and position
rsb.id <- map(.x = rsb,
            .f = ~ mutate(.x, chr.pos = str_c(CHR, "_", POSITION)) %>% 
              left_join(select(g.pos, chr.pos, SNPid, cM), ., by = "chr.pos" ) %>% 
              select(., -chr.pos) %>% 
              select(., SNPid, cM, RSB, LOGPVALUE, everything()) )

# update Xpe with chr and position
xpe.id <- map(.x = xpe,
            .f = ~ mutate(.x, chr.pos = str_c(CHR, "_", POSITION)) %>% 
              left_join(select(g.pos, chr.pos, SNPid, cM), ., by = "chr.pos" ) %>%
              select(., -chr.pos) %>% 
              select(., SNPid, cM, XPEHH, LOGPVALUE, everything()) )
head(xpe$both.all2)
head(xpe.id$both.all2)

# update fst with chr and position
fst.id <- map(.x = fst,
            .f = ~ mutate(.x, chr.pos = str_c(CHR, "_", POSITION)) %>% 
              left_join(select(g.pos, chr.pos, SNPid, cM), ., by = "chr.pos" ) %>%
              select(., -chr.pos) %>% 
              select(., SNPid, cM, FST, everything()) )

# consolidate all results ----
pop.pairs <- res$pop.pairs
# calculate PIC values will allele frequencies
final <- map2(.x = pop.pairs$pop1, .y = pop.pairs$pop2,
            .f = ~ consolidate_results(pop1 = .x, pop2 = .y) )
names(final) <- pop.pairs$pop1
rm(rsb, xpe, fst, allele.freq)

# correlation between the three stats ----
# for correlation between FST and RSB/XPEHH, use the absolute values of the EHH based statistics.
cor.res <- list(fst.rsb = map_dbl(.x = final, .f = ~ cor(x = .x[["FST"]], y = .x[["RSB"]] %>% abs(), use = "pairwise.complete.obs", method = "pearson") ),
                fst.xpe = map_dbl(.x = final, .f = ~ cor(x = .x[["FST"]], y = .x[["XPEHH"]] %>% abs(), use = "pairwise.complete.obs", method = "pearson") ),
                rsb.xpe = map_dbl(.x = final, .f = ~ cor(x = .x[["RSB"]], y = .x[["XPEHH"]], use = "pairwise.complete.obs", method = "pearson") ) )
```

# Combine and preprocess candidate regions
Start this chunk by loading the raw outputs of candidate region search from the chunk above
```{r combine and save candidate regions}
cr.rsb.df <- mutate(cr.rsb.df, Stat = "Rsb") 
cr.xpe.df <- mutate(cr.xpe.df, Stat = "xpEHH")
cr.fst.df <- mutate(cr.fst.df, Stat = "Fst")

# Merge the fst, rsb and xpehh candidate regions files ----
names(cr.rsb.df)
df <- rbind(cr.rsb.df, cr.xpe.df, cr.fst.df) %>% 
  mutate(Genome = str_sub(CHR, 2, 2), 
         KB = (END - START)/1000,
         POP = str_c(Pops, " (", Stat, " ", 
                      sprintf("%.2f", round(MAX_MRK, digits = 2)), ", ", 
                      # sprintf is to prevent R from dropping trailing zeroes
                      N_EXTR_MRK, "/", N_MRK, ")")) %>% 
  # Select and order the columns
  select(., Genome, CHR, START, END, KB, POP, Stat, Category, Habit, Pops, 
         N_MRK, N_EXTR_MRK, PERC_EXTR_MRK, MEAN_MRK, MAX_MRK, MEAN_EXTR_MRK) %>% # removed cM, SNP and Name
  arrange(., CHR, START, POP)
# divide physical position by a million
df <- mutate(df, START = START/1e6)
df <- mutate(df, END = END/1e6)
# add lines to add Genome (str_sub) and Percentage Extremal Markers.
table(df$Category) # total candidate regions by population
table(cr.fst.df$Category) # total FST candidate regions by population
table(cr.rsb.df$Category) # total RSB candidate regions by population
table(cr.xpe.df$Category) # total xpEHH candidate regions by population
table(df$CHR) # total candidate regions by chromosome
table(cr.fst.df$CHR) # total FST candidate regions by chromosome
table(cr.rsb.df$CHR) # total RSB candidate regions by chromosome
table(cr.xpe.df$CHR) # total xpEHH candidate regions by chromosome

median(df$KB)
group_by(df, Stat) %>% 
  summarise(mean = mean(KB), median = median(KB), min = min(KB), max = max(KB))

cr.param <- str_c("cr-thres", param$thres, 
                  "-mrk", param$min.mrk, 
                  "-per", param$min.perc,
                  "-ws", param$ws/1000, "Kb",
                  "-ovr", param$ovr*100, "per")
scan_hh.param <- paste0("-pol-",  res$scan_hh.parameters$polarized.value, # paste0 converts NA to character
                        "-sgap-", res$scan_hh.parameters$scale.gap.value,
                        "-mgap-", res$scan_hh.parameters$max.gap.value,
                        "-discardBorder-", res$scan_hh.parameters$discard.integration.at.border, "-")
raw.results <- list(final = final, cr.consolidated = df, corr = cor.res, 
                    quantile.threshold.95 = quantile.threshold.95, quantile.threshold.99 = quantile.threshold.99, quantile.threshold.997 = quantile.threshold.997)
saveRDS(raw.results, "output/raw_results_for_cr_search.RDS")
write_csv(df, str_c("output/cr_consolidated.csv"))
```

